```
setTimeout(() => {
    console.log('1')
    setTimeout(() => {
        console.log('2')
    }, 100)
}, 100)

setTimeout(() => {
    console.log('3')
    setTimeout(() => {
        console.log('4')
    }, 0)
}, 200)
```

上面程序执行的结果：
如果主线程没有其他的执行
```
1，3，2，4
```

还有一种情况：  
```
1,3,4,2
```

原因请往下看：


js是单线程的语言  
```
setTimeout(() => {
    console.log('yt! hardsome!')
}, 100)
```

setTimeout的执行是：将定时的回调放置到回调队列内去，根据延时时间（100ms）去执行这个回调  
但这时如果主线程被占用，那就等待， 直到主线程为空，再去执行这个回调；所以最后执行的时间肯定是大于等于延时时间

所以上述的第二种情况可以就解释了：  

我们称第一个定时器为timer1，内部的为timer1_1；以此类推；  

想象一个一维时间轴，以程序一开始执行的时间为原点0，在100ms时即将执行timer1，但这时主线程还不为空，等待了n（ms）执行，那timer1_1的定时回调时间为 100 + n + 100 = (200 + n)ms，当  
当时间轴到达200ms时，也需要等待主线程为空 等待m（ms），时间轴又向后推进；

```
const minTimer = 4
if (200 + n > 200 + m + minTimer) {
    console.log(1,3,4,2)
}
```  
